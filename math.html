<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Math grapher</title>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.16.0/dist/pixi.min.js"></script>
    <link rel="stylesheet" href="css/mainstyle.css" type="text/css">
</head>

<body>
    <header>
        <h3>Math Grapher</h3>
        <p>A tool for visualizing graphs of mathematical functions for educational and research purposes.</p>
    </header>
    <main>
        <div id="game-container"></div>
        <div id="controls" style="padding: 15px; background: #1a1a1a; color: white; font-family: sans-serif;">
            <div id="functions-list">
            </div>
            <button id="add-func" style="margin-top: 10px; cursor: pointer;">+ Add funcion</button>
            <button id="reset-func" style="margin-top: 10px; cursor: pointer;">Remove All</button>
            <div
                style="margin-top: 15px; color: #777; font-size: 0.85em; border-top: 1px solid #333; padding-top: 10px;">
                <strong>Hint:</strong> Use JavaScript syntax.<br>
                Available: <code>Math.sin(x)</code>, <code>Math.cos(x)</code>, <code>Math.abs(x)</code>,
                <code>Math.pow(x, 3)</code>, <code>x * x</code>
            </div>
            <button id="zoom-in" style="margin-top: 10px; cursor: pointer;">Zoom in</button>
            <button id="zoom-out" style="margin-top: 10px; cursor: pointer;">Zoom out</button>
        </div>
        <a href="index.html">Home</a>
    </main>
    <footer>
        <p>Built with ‚ù§Ô∏è using HTML, CSS, JS, and Pixi!</p>
    </footer>
</body>

<script type="module">
    /**
    * –°—Ç–∞—Ç—É—Å –ø—Ä–æ–µ–∫—Ç–∞: PixiJS Grapher
    * –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ: 
    * - –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Ñ—É–Ω–∫—Ü–∏–π y=f(x) —á–µ—Ä–µ–∑ new Function
    * - –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è —Å–µ—Ç–∫–∞ —Å –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º —à–∞–≥–æ–º
    * - Panning (–ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ) –∏ Zoom (–∫–æ–ª–µ—Å–∏–∫–æ)
    * - –í–∞–ª–∏–¥–∞—Ü–∏—è –≤–≤–æ–¥–∞ (–∫—Ä–∞—Å–Ω–∞—è —Ä–∞–º–∫–∞) –∏ LocalStorage
    * - "–õ–∏–ø–∫–∏–µ" –æ—Å–∏ (Sticky Axes) –∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ø–æ–¥ –º—ã—à—å—é
    */

    // –ö–ª—é—á –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ –±—Ä–∞—É–∑–µ—Ä–µ
    const STORAGE_KEY = 'pixi_graph_functions';

    const defaultFunctions = [
        { id: Date.now(), formula: 'x * x', color: '#00ff00', visible: true }
    ];

    // –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–∑ LocalStorage –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥–µ—Ñ–æ–ª—Ç, –µ—Å–ª–∏ —Ç–∞–º –ø—É—Å—Ç–æ
    let functions = JSON.parse(localStorage.getItem(STORAGE_KEY)) ||
        defaultFunctions;

    function saveToStorage() {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(functions));
    }

    function resetAll() {
        localStorage.removeItem(STORAGE_KEY);
        location.reload(); // –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç —Å—Ç—Ä–∞–Ω–∏—Ü—É —Å –¥–µ—Ñ–æ–ª—Ç–Ω—ã–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏
    }

    const listContainer = document.getElementById('functions-list');

    // –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è UI –¥–ª—è —Å—Ç—Ä–æ–∫–∏ –≥—Ä–∞—Ñ–∏–∫–∞
    function renderInputs() {
        listContainer.innerHTML = '';
        functions.forEach((func, index) => {
            const row = document.createElement('div');
            row.style.marginBottom = '10px';

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å —Ñ–æ—Ä–º—É–ª—ã –¥–ª—è –ø–æ–¥—Å–≤–µ—Ç–∫–∏
            const isValid = !isNaN(evaluateY(func.formula, 1));
            const borderColor = isValid ? '#444' : '#ff4444';

            row.innerHTML = `
            <button onclick="toggleVisibility(${index})" style="background:none; border:none; cursor:pointer; font-size:18px; vertical-align:middle; width:30px;">
                ${func.visible ? 'üëÅÔ∏è' : 'üï∂Ô∏è'}
            </button>
            <span style="color: #888; font-family: monospace;">y = </span>
            <input type="text" 
                   class="formula-input" 
                   data-index="${index}" 
                   value="${func.formula}" 
                   style="width: 250px; padding: 5px; border-radius: 4px; border: 2px solid ${borderColor}; background: #333; color: white;">
            <input type="color" 
                   class="color-input" 
                   data-index="${index}" 
                   value="${func.color}" 
                   style="vertical-align: middle; cursor: pointer;">
            <button onclick="removeFunc(${index})" style="color: #ff5555; background: none; border: none; cursor: pointer; font-size: 18px; vertical-align: middle;">‚úï</button>
        `;
            listContainer.appendChild(row);
        });
    }

    // –°–ª—É—à–∞—Ç–µ–ª–∏ —Å–æ–±—ã—Ç–∏–π –¥–ª—è –∏–Ω–ø—É—Ç–æ–≤
    listContainer.addEventListener('input', (e) => {
        const index = e.target.dataset.index;
        if (e.target.classList.contains('formula-input')) {
            const formula = e.target.value;
            functions[index].formula = formula;

            // –í–ê–õ–ò–î–ê–¶–ò–Ø "–ù–ê –õ–ï–¢–£"
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º—É–ª—É –Ω–∞ —Ç–µ—Å—Ç–æ–≤–æ–º –∑–Ω–∞—á–µ–Ω–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, x = 1)
            const result = evaluateY(formula, 1);
            const isValid = result !== undefined && !isNaN(result);

            // –ú–µ–Ω—è–µ–º —Ü–≤–µ—Ç —Ä–∞–º–∫–∏ —Ç–µ–∫—É—â–µ–≥–æ –∏–Ω–ø—É—Ç–∞ –±–µ–∑ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∏ –≤—Å–µ–≥–æ —Å–ø–∏—Å–∫–∞
            e.target.style.borderColor = isValid ? '#444' : '#ff4444';
        }

        if (e.target.classList.contains('color-input')) {
            functions[index].color = e.target.value;
        }

        saveToStorage();
        drawGraph(); // –ü–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –≥—Ä–∞—Ñ–∏–∫ –Ω–∞ —Ö–æ–ª—Å—Ç–µ
    });


    window.toggleVisibility = (index) => {
        functions[index].visible = !functions[index].visible;

        saveToStorage();
        renderInputs(); // –ü–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫–∏ (–≥–ª–∞–∑–∏–∫)
        drawGraph();    // –ü–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –≥—Ä–∞—Ñ–∏–∫–∏ –Ω–∞ —Ö–æ–ª—Å—Ç–µ
    };

    document.getElementById('add-func').onclick = () => {
        functions.push({ id: Date.now(), formula: 'Math.sin(x)', color: '#ff00ff', visible: true });

        renderInputs();
        saveToStorage();
        drawGraph();
    };

    document.getElementById('reset-func').onclick = () => {
        resetAll();
    }

    window.removeFunc = (index) => {
        functions.splice(index, 1);
        if (functions.length === 0) {
            functions.push({ id: Date.now(), formula: '0', color: '#ffffff', visible: true });
        }

        renderInputs();
        saveToStorage();
        drawGraph();
    };

    // –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –≤—ã—á–∏—Å–ª–∏—Ç–µ–ª—å
    function evaluateY(formula, x) {
        try {
            const f = new Function('x', 'Math', `return ${formula};`);
            return f(x, Math);
        } catch {
            return undefined;
        }
    }

    const gameContainer = document.getElementById('game-container');
    const app = new PIXI.Application();

    await app.init({
        resizeTo: gameContainer,
        autoDensity: true, // –ü–æ–¥–¥–µ—Ä–∂–∫–∞ Retina/High-DPI —ç–∫—Ä–∞–Ω–æ–≤
        antialias: true,
        backgroundColor: 0x1099bb
    });

    gameContainer.appendChild(app.canvas)

    // 4. –°–æ–∑–¥–∞–µ–º –≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–π –æ–±—ä–µ–∫—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∫—Ä–∞—Å–Ω—ã–π –∫–≤–∞–¥—Ä–∞—Ç)
    const graph = new PIXI.Graphics();
    app.stage.addChild(graph);

    const labelsContainer = new PIXI.Container();
    app.stage.addChild(labelsContainer);

    let scale = 40; // –ù–∞—á–∞–ª—å–Ω—ã–π –º–∞—Å—à—Ç–∞–± (–ø–∏–∫—Å–µ–ª–µ–π –Ω–∞ 1 –µ–¥–∏–Ω–∏—Ü—É)
    let centerX = app.screen.width / 2;
    let centerY = app.screen.height / 2;
    let isDragging = false;
    let lastMousePos = { x: 0, y: 0 };

    let touchZoom = undefined;  // [initialDist, initialScale]
    app.stage.eventMode = 'static'; // –í–∫–ª—é—á–∞–µ–º –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –¥–ª—è —Å—Ü–µ–Ω—ã
    app.stage.hitArea = app.screen; // –û–±–ª–∞—Å—Ç—å –∫–ª–∏–∫–∞ ‚Äî –≤–µ—Å—å —ç–∫—Ä–∞–Ω

    // –ú–µ–Ω—è–µ–º –∫—É—Ä—Å–æ—Ä –Ω–∞ "—Ä—É–∫—É"
    app.canvas.style.cursor = 'grab';

    app.stage.on('pointerdown', (e) => {
        if (touchZoom) {
            isDragging = false;
            tooltip.visible = false;
        } else {
            isDragging = true;
            lastMousePos = { x: e.global.x, y: e.global.y };
            app.canvas.style.cursor = 'grabbing';
        }
    });

    window.addEventListener('pointerup', () => {
        isDragging = false;
        app.canvas.style.cursor = 'grab';
    });

    // –°–∫—Ä—ã–≤–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã, –∫–æ–≥–¥–∞ –º—ã—à—å —É—Ö–æ–¥–∏—Ç —Å —Ö–æ–ª—Å—Ç–∞
    app.stage.on('pointerleave', () => {
        tooltip.visible = false;
    });

    app.stage.on('pointermove', (e) => {
        const mouseX = e.global.x;
        const mouseY = e.global.y;

        // 1. –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º —ç–∫—Ä–∞–Ω–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ
        const mathX = ((mouseX - centerX) / scale).toFixed(2);
        const mathY = (-(mouseY - centerY) / scale).toFixed(2); // –ò–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º Y

        // 2. –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç –∏ –ø–æ–∑–∏—Ü–∏—é —Ç—É–ª—Ç–∏–ø–∞
        tooltip.text = `(${mathX}, ${mathY})`;
        tooltip.x = mouseX + 15; // –°–º–µ—â–µ–Ω–∏–µ –≤–ø—Ä–∞–≤–æ –æ—Ç –∫—É—Ä—Å–æ—Ä–∞
        tooltip.y = mouseY - 25; // –°–º–µ—â–µ–Ω–∏–µ —á—É—Ç—å –≤—ã—à–µ –∫—É—Ä—Å–æ—Ä–∞
        tooltip.visible = true;

        if (isDragging) {
            // –í—ã—á–∏—Å–ª—è–µ–º, –Ω–∞ —Å–∫–æ–ª—å–∫–æ —Å–¥–≤–∏–Ω—É–ª–∞—Å—å –º—ã—à—å
            const dx = e.global.x - lastMousePos.x;
            const dy = e.global.y - lastMousePos.y;

            // –°–¥–≤–∏–≥–∞–µ–º —Ü–µ–Ω—Ç—Ä –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
            centerX += dx;
            centerY += dy;

            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —à–∞–≥–∞
            lastMousePos = { x: e.global.x, y: e.global.y };

            // –ü–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –≤—Å—ë
            drawGraph();
        }
    });

    app.canvas.addEventListener('dblclick', () => {
        centerX = app.screen.width / 2;
        centerY = app.screen.height / 2;
        scale = 40;
        drawGraph();
    });

    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–π —Å—Ç–∏–ª—å –¥–ª—è —Ç–µ–∫—Å—Ç–∞
    const textStyle = new PIXI.TextStyle({
        fontSize: 14,
        fill: 0xaaaaaa,
    });

    const tooltip = new PIXI.Text({
        text: '',
        style: {
            fontSize: 14,
            fill: 0xffffff,
            dropShadow: { alpha: 0.5, blur: 2, color: '#000000', distance: 1 }
        }
    });
    tooltip.visible = false; // –°–∫—Ä—ã—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    app.stage.addChild(tooltip);

    function getOptimalStep(currentScale) {
        const minSpacing = 50; // –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –ª–∏–Ω–∏—è–º–∏ –≤ –ø–∏–∫—Å–µ–ª—è—Ö
        const availableSteps = [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000];

        // –ò—â–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —à–∞–≥, –∫–æ—Ç–æ—Ä—ã–π –¥–∞—Å—Ç —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ > minSpacing
        for (let s of availableSteps) {
            if (s * currentScale >= minSpacing) return s;
        }

        // –ï—Å–ª–∏ –º–∞—Å—à—Ç–∞–± —Å–æ–≤—Å–µ–º –∫—Ä–æ—à–µ—á–Ω—ã–π (—Å–∏–ª—å–Ω–æ–µ –æ—Ç–¥–∞–ª–µ–Ω–∏–µ)
        const power = Math.pow(10, Math.ceil(Math.log10(minSpacing / currentScale)));
        return power;
    }

    function drawGraph() {
        graph.clear();
        labelsContainer.removeChildren();

        const dynamicStep = getOptimalStep(scale); // –ü–æ–ª—É—á–∞–µ–º 1, 2, 5 –∏–ª–∏ 10...

        // 2. –†–∏—Å—É–µ–º –æ—Å–∏
        graph.setStrokeStyle({ width: 2, color: 0xffffff });

        // –ü–ª–∞–≤–∞—é—â–∞—è –æ—Å—å X (–≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è)
        // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º Y-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—É –æ—Å–∏ —Ç–∞–∫, —á—Ç–æ–±—ã –æ–Ω–∞ –Ω–µ –≤—ã—Ö–æ–¥–∏–ª–∞ –∑–∞ –ø—Ä–µ–¥–µ–ª—ã —ç–∫—Ä–∞–Ω–∞ (—Å –æ—Ç—Å—Ç—É–ø–æ–º 2px)
        const stickyY = Math.max(2, Math.min(app.screen.height - 2, centerY));
        graph.moveTo(0, stickyY).lineTo(app.screen.width, stickyY);

        // –ü–ª–∞–≤–∞—é—â–∞—è –æ—Å—å Y (–≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è)
        const stickyX = Math.max(2, Math.min(app.screen.width - 2, centerX));
        graph.moveTo(stickyX, 0).lineTo(stickyX, app.screen.height);

        graph.stroke();

        // 1. –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è —Å–µ—Ç–∫–∞
        graph.setStrokeStyle({ width: 1, color: 0x333333 });

        // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ (X)
        const leftBound = Math.floor(-centerX / (scale * dynamicStep));
        const rightBound = Math.ceil((app.screen.width - centerX) / (scale * dynamicStep));

        for (let i = leftBound; i <= rightBound; i++) {
            const xPos = centerX + i * dynamicStep * scale;

            // –†–∏—Å—É–µ–º —á–∏—Å–ª–∞ —Ç–æ–ª—å–∫–æ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ —à–∞–≥–∞
            if (i !== 0) {
                graph.moveTo(xPos, 0).lineTo(xPos, app.screen.height);
                const xText = new PIXI.Text({ text: (i * dynamicStep).toString(), style: textStyle });
                xText.x = xPos;
                // –ü—Ä–∏–∂–∏–º–∞–µ–º —Ç–µ–∫—Å—Ç –∫ –Ω–∏–∂–Ω–µ–π —á–∞—Å—Ç–∏ –æ—Å–∏, –Ω–æ –Ω–µ –¥–∞–µ–º —É–π—Ç–∏ –∑–∞ —ç–∫—Ä–∞–Ω
                xText.y = Math.max(5, Math.min(app.screen.height - 25, stickyY + 5));
                xText.anchor.set(0.5, 0);
                labelsContainer.addChild(xText);
            }
        }

        // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ (Y)
        const topBound = Math.floor((centerY - app.screen.height) / (scale * dynamicStep));
        const bottomBound = Math.ceil(centerY / (scale * dynamicStep));

        for (let i = topBound; i <= bottomBound; i++) {
            const yPos = centerY - i * dynamicStep * scale;

            if (i !== 0) {
                graph.moveTo(0, yPos).lineTo(app.screen.width, yPos);
                const yText = new PIXI.Text({ text: (i * dynamicStep).toString(), style: textStyle });
                // –ü—Ä–∏–∂–∏–º–∞–µ–º —Ç–µ–∫—Å—Ç –∫ –ª–µ–≤–æ–π —á–∞—Å—Ç–∏ –æ—Å–∏
                yText.x = Math.max(35, Math.min(app.screen.width - 10, stickyX - 10));
                yText.y = yPos;
                yText.anchor.set(1, 0.5);
                labelsContainer.addChild(yText);
            }
        }

        const zeroText = new PIXI.Text({ text: '0', style: textStyle });
        zeroText.x = Math.max(15, Math.min(app.screen.width - 15, stickyX - 10));
        zeroText.y = Math.max(5, Math.min(app.screen.height - 25, stickyY + 5));
        zeroText.anchor.set(1, 0);
        labelsContainer.addChild(zeroText);

        graph.stroke();

        // 3. –†–∏—Å—É–µ–º —Ñ—É–Ω–∫—Ü–∏–∏
        // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –≤—Å–µ—Ö —Ñ—É–Ω–∫—Ü–∏–π –∏–∑ –º–∞—Å—Å–∏–≤–∞
        functions.forEach(func => {
            if (!func.visible)
                return;

            const hexColor = parseInt(func.color.replace('#', '0x'));
            graph.setStrokeStyle({ width: 3, color: hexColor });

            let first = true;
            let hasError = false;

            for (let screenX = 0; screenX <= app.screen.width; screenX += 2) {
                let x = (screenX - centerX) / scale;
                let y = evaluateY(func.formula, x);

                if (isNaN(y)) {
                    hasError = true;
                    continue;
                }

                let screenY = centerY - y * scale;

                if (first) {
                    graph.moveTo(screenX, screenY);
                    first = false;
                } else {
                    if (screenY > -1000 && screenY < app.screen.height + 1000) {
                        graph.lineTo(screenX, screenY);
                    } else {
                        graph.moveTo(screenX, screenY);
                    }
                }
            }
            graph.stroke();
        });
    }

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–ª–µ—Å–∏–∫–∞ –º—ã—à–∏
    window.addEventListener('wheel', (e) => {
        // –ò–∑–º–µ–Ω—è–µ–º –º–∞—Å—à—Ç–∞–±: –ø—Ä–æ–∫—Ä—É—Ç–∫–∞ –≤–≤–µ—Ä—Ö ‚Äî —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º, –≤–Ω–∏–∑ ‚Äî —É–º–µ–Ω—å—à–∞–µ–º
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        scale *= delta;

        // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è, —á—Ç–æ–±—ã –Ω–µ —É–π—Ç–∏ –≤ –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ—Å—Ç—å
        scale = Math.min(Math.max(scale, 5), 500);

        drawGraph();
    });


    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –º–µ–∂–¥—É –¥–≤—É–º—è –ø–∞–ª—å—Ü–∞–º–∏
    const getDistance = (touches) => {
        return Math.hypot(
            touches[0].pageX - touches[1].pageX,
            touches[0].pageY - touches[1].pageY
        );
    };

    window.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
            // –ó–∞–ø–æ–º–∏–Ω–∞–µ–º –Ω–∞—á–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –∏ —Ç–µ–∫—É—â–∏–π –º–∞—Å—à—Ç–∞–±
            touchZoom = [getDistance(e.touches), scale];
        }
    }, { passive: false });

    window.addEventListener('touchmove', (e) => {

        if (e.touches.length === 2 && touchZoom) {
            e.preventDefault(); // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –∑—É–º –±—Ä–∞—É–∑–µ—Ä–∞
            const initialDist = touchZoom[0];
            const initialScale = touchZoom[1];

            const currentDist = getDistance(e.touches);

            // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –Ω–æ–≤—ã–π –º–∞—Å—à—Ç–∞–± –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–æ –∏–∑–º–µ–Ω–µ–Ω–∏—é —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è
            const delta = currentDist / initialDist;
            scale = initialScale * delta;

            // –ü—Ä–∏–º–µ–Ω—è–µ–º –≤–∞—à–∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è
            scale = Math.min(Math.max(scale, 5), 500);

            drawGraph();
        }
    }, { passive: false });

    window.addEventListener('touchend', () => {
        touchZoom = undefined; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º  –ø—Ä–∏ –æ—Ç–ø—É—Å–∫–∞–Ω–∏–∏ –ø–∞–ª—å—Ü–µ–≤
    });

    renderInputs();
    drawGraph();
</script>

</html>